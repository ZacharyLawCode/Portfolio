<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Stock Trade Logger</title>
  
  <!-- Chart.js & Financial Chart Plugin -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>

  <!-- âœ… FIX: Add Moment.js & Chart.js Date Adapter -->
  <script src="https://cdn.jsdelivr.net/npm/moment"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment"></script>

  <style>
    /* Centering the chart */
    #chart-container {
      width: 90%; /* Increase the width of the chart container */
      max-width: 2000px; /* Optional: Limit the maximum width */
      height: 1000px; /* Double the height of the chart */
      margin: 0 auto 0px auto; /* Center the chart horizontally and reduce bottom margin */
    }

    table {
      width: 80%; /* Adjust the table width to align with the chart */
      border-collapse: collapse;
      margin-top: 10px; /* Adjust top margin to reduce space between chart and table */
    }

    th, td {
      border: 1px solid black;
      padding: 8px;
      text-align: center;
    }

    th {
      background-color: #f2f2f2;
    }

    .total-row {
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div id="chart-container">
    <canvas id="chart"></canvas>
  </div>

  <h2>Trade Log</h2>
  <table>
    <thead>
      <tr>
        <th>Date</th>
        <th>Action</th>
        <th>Price</th>
        <th>Net Difference</th>
      </tr>
    </thead>
    <tbody id="trade-log"></tbody>
  </table>

  <script>
    async function fetchBars() {
      try {
        const response = await fetch('http://localhost:3000/api/bars');
        if (!response.ok) {
          throw new Error(`Error: ${response.statusText}`);
        }
        const bars = await response.json();
        if (bars && bars.length > 0) {
          const chartData = formatDataForChart(bars);
          console.log("Formatted Chart Data: ", chartData);  // Debugging
          plotChart(chartData, bars);  // Pass both chart data and bar data
          logTrades(bars);
        } else {
          console.error('No data found.');
        }
      } catch (error) {
        console.error("Error fetching candlestick data:", error);
      }
    }

    function formatDataForChart(bars) {
      return bars.map(bar => {
        const formattedDate = moment(bar.Timestamp).toDate(); // Use moment.js to format date
        const timestamp = moment(formattedDate).valueOf();  // Convert to timestamp (milliseconds)
        console.log("Formatted Date (Timestamp): ", timestamp);  // Debugging
        return {
          x: timestamp,  // Use timestamp for x-axis
          o: bar.OpenPrice,
          h: bar.HighPrice,
          l: bar.LowPrice,
          c: bar.ClosePrice
        };
      });
    }

    function plotChart(data, bars) {
      const ctx = document.getElementById('chart').getContext('2d');

      new Chart(ctx, {
        type: 'candlestick',
        data: {
          datasets: [{
            label: 'Stock Prices',
            data: data,
            borderColor: 'black',
            color: {
              up: 'green',
              down: 'red',
              unchanged: 'gray'
            },
            barThickness: 5,  // Adjusts the candle width
            categoryPercentage: 0.8, // Controls spacing between candles
            barPercentage: 0.8, // Adjusts bar width inside category space
          }]
        },
        options: {
          responsive: true,
          plugins: {
            tooltip: {
              enabled: true,
              callbacks: {
                label: function(context) {
                  return context.raw.c.toFixed(2); // Show the close price in the tooltip
                }
              }
            },
            annotation: {
              annotations: bars.map((bar, index) => {
                const action = (index % 2 === 0) ? "BUY" : "SELL";

                // Create marker based on action (BUY or SELL)
                return {
                  type: 'point',
                  xValue: moment(bar.Timestamp).valueOf(),
                  yValue: bar.ClosePrice,
                  radius: 5,
                  backgroundColor: action === 'BUY' ? 'green' : 'red',
                  pointStyle: action === 'BUY' ? 'triangle' : 'triangle',
                  label: {
                    content: action === 'BUY' ? 'BUY' : 'SELL',
                    enabled: true,
                    position: 'top'
                  }
                };
              })
            }
          },
          scales: {
            x: {
              type: 'time', // Time scale for the x-axis
              time: {
                unit: 'day', // Show daily data
                tooltipFormat: 'll', // Format the tooltip
                displayFormats: {
                  day: 'MM/DD/YYYY' // Use numeric date format on the x-axis (e.g., 01/01/2024)
                }
              },
              title: {
                display: true,
                text: 'Date'
              },
              ticks: {
                autoSkip: true,
                maxTicksLimit: 10  // Prevent overcrowding of labels
              }
            },
            y: {
              title: {
                display: true,
                text: 'Price'
              }
            }
          }
        }
      });
    }

    function logTrades(bars) {
      let lastBuyPrice = null;
      let totalNetDifference = 0;  // Initialize total net difference
      const logTable = document.getElementById('trade-log');

      bars.forEach(bar => {
        const date = new Date(bar.Timestamp);
        const day = date.getDate();
        const action = (day % 2 === 0) ? "BUY" : "SELL";
        const price = bar.ClosePrice;
        let netDifference = '';

        if (action === "BUY") {
          // For BUY, leave net difference blank
          lastBuyPrice = price;  // Store the price of the last BUY
        } else if (action === "SELL" && lastBuyPrice !== null) {
          // For SELL, calculate the net difference between the last BUY and current SELL
          netDifference = (price - lastBuyPrice).toFixed(2);
          totalNetDifference += parseFloat(netDifference);  // Add the net difference to the total
          lastBuyPrice = null;  // Reset lastBuyPrice after the SELL
        }

        const row = ` 
          <tr>
            <td>${date.toDateString()}</td>
            <td>${action}</td>
            <td>${price.toFixed(2)}</td>
            <td>${netDifference}</td>
          </tr>
        `;
        logTable.innerHTML += row;
      });

      // Add total net difference row at the bottom
      const totalRow = `
        <tr class="total-row">
          <td colspan="3">Total Net Difference</td>
          <td>${totalNetDifference.toFixed(2)}</td>
        </tr>
      `;
      logTable.innerHTML += totalRow;  // Append the total row
    }

    fetchBars();
  </script>
</body>
</html>
